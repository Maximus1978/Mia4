# ADR-0021: Max Token Cap & Sampling Observability Semantics

Status: Draft
Date: 2025-09-03

## Контекст

В системе появились модельные паспорта (ADR-0016) и необходимость:
1. Гарантировать верхний предел `max_output_tokens` (cap) согласно паспорту / политике.
2. Избежать "тихого" урезания без видимости для пользователя и мониторинга.
3. Синхронизировать UI (авто‑применение лимита, отображение `/ \<limit\>` и подсветка достижения).
4. Сохранить пользовательские кастомные значения при переключении моделей, если они валидны под новым лимитом.
5. Устранить расхождения между паспортом и `configs/base.yaml`.

## Решение

Вводим формализованную семантику cap:

- `effective_max_tokens = min(requested_max_tokens, passport.max_output_tokens)`.
- Если произведено урезание (requested > passport), ставим флаг `cap_applied = true`.
- Фактическое значение записывается:
  - `GenerationStarted.sampling.max_tokens`
  - `GenerationCompleted.result_summary.sampling.max_tokens`
- Флаг `cap_applied` дублируется в обоих событиях.
- Метрика `model_cap_hits_total{model}` инкрементируется при каждом урезании.
- Появляется warning событие `ModelPassportMismatch` при несоответствии лимитов паспорта и конфигурации.
- UI обязан отображать рядом поле ввода формат `<current> / <limit>` и визуально сигнализировать достижение предела.
- UI при смене модели:

  1. Берёт сохранённое пользовательское значение (если есть).
  2. Сравнивает с новым паспортным лимитом.
  3. Если сохранённое <= новый лимит — сохраняет.
  4. Если > лимита — приводит к лимиту, однократно показывает toast/badge "capped to \<limit\>".
- Reset temperature/top_p выполняется только если предыдущее значение == прежним дефолтам (избегаем потери кастома).

## Варианты

1. Silent Cap (урезать без флагов и метрик) — отклонено.
2. Reject Request (HTTP 400 при превышении) — ухудшает UX, требует дополнительного раунда.
3. Soft Warn (только лог без метрики) — недостаточная наблюдаемость.
4. Client-side Enforcement (полагаться на UI) — ненадёжно, риск обхода.

## Обоснование

Выбранный подход даёт:

- Прозрачность (в событиях и UI) и машинно‑читаемую аудит-трассу.
- Совместимость с ретроспективной аналитикой (метрика + события).
- Минимум трения для пользователя (не нужно повторно отправлять запрос).

## Последствия

### Положительные

- Репродуцируемость экспериментов (видно фактическое значение и cap факт).
- Снижение скрытых ошибок интерпретации длины ответа.
- Улучшенная диагностика при деградациях (рост метрики cap_hits).

### Отрицательные

- Лёгкое расширение payload событий (несколько дополнительных полей).
- Дополнительные UI состояния (toast, подсветка) — небольшой фронтовый оверхед.

## Безопасность / Наблюдаемость

- Метрика `model_cap_hits_total{model}` → алерт при резком росте.
- Логирование warning `ModelPassportMismatch` с полями: model_id, passport_value, config_value.
- Возможность корелляции с производительностью (связь длины и latency).

## Тестирование

- Unit: функция вычисления effective_max_tokens (граничные случаи, равенство, превышение, нулевые/отрицательные значения → нормализуем >=1).
- Integration: сценарий переключения моделей (primary→phi→primary) с сохранением кастомного значения.
- Metrics: искусственная отправка запроса с превышением лимита увеличивает счётчик.
- Contract: наличие полей `max_tokens` и `cap_applied` в обоих событиях.

## Миграция

- Добавить поля в события (backward compatible — только расширение).
- Обновить `API.md` и `Config-Registry.md` (секция правил превышения лимита).
- В changelog зафиксировать дату включения cap семантики.

## Связанные документы

- ADR-0016 (Passports)
- Execution Plan Step 7 (Sampling & Max Token Cap)

## Открытые вопросы

- Нужно ли на уровне политики вводить soft-warning порог (например 90% лимита) — отложено.
- Отдельная метрика percent_of_cap (гистограмма) — отложено.

## Примечания

Может быть расширено адаптивными лимитами (heuristic prompt length) в отдельном ADR.
