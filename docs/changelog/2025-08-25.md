# Changelog — 2025-08-25

Part 1
## Modular Core Refactor (Sprint S1–S7) Completed

Status: All planned phases S1–S7 marked [x]; architecture transitioned from monolithic RootConfig / implicit factories to modular config + ModuleManager with capability routing and generation contract. Documentation & guardrails in place.

### Key Deliverables

- S1: Split monolithic RootConfig into modular Pydantic schemas (`core.config.schemas.*`), added `schema_version`, migration for legacy YAML, `modules.enabled` list.
- S2: Introduced `ModuleDescriptor` + `ModuleManager` (lazy init) with first `LLMModule` registration.
- S3: Moved optional model / routing / idle sweep logic from `core.llm.factory` into `LLMModule`; factory left as transitional shim.
- S4: Capability-based routing: provider selection by manifest `capabilities[]` with primary fallback; capabilities attached to provider info.
- S5: Standardized `GenerationResult` (text, usage.prompt_tokens, usage.completion_tokens, timings.total_ms, timings.decode_tps) maintaining backward-compatible `generate()`.
- S6: Import graph static analyzer (`core/dev/import_graph.py`) + test `test_import_graph_no_cycles` enforcing forbidden edges (module layering invariants) with explicit transitional exception for legacy factory.
- S7: Documentation sync: updated `README.md`, `Config-Registry.md`, `Perf.md`, project structure doc; added auto generator `scripts/generate_config_docs.py` producing `docs/ТЗ/Generated-Config.md` + sync test.

### Architectural Invariants Enforced

- Modules do not import `core.modules.module_manager` (single orchestration point) — transitional exception only for `core.llm.factory`.
- No mutual dependencies between future perf/rag/memory/observability and llm (preemptively guarded).
- Capability routing fallback: absence of required capability never breaks call path (always returns primary provider).
- Config keys validated strictly (extra forbidden inside each namespace).

### Tests Added / Updated

- Migration: legacy config without schema_version.
- Module manager registration & unknown module handling.
- LLM routing by role & capabilities (+ fallback path).
- Idle sweep behavior after refactor.
- GenerationResult contract (fields presence & usage metrics).
- Import graph cycle & forbidden edge test.
- Generated config docs sync test.

### Documentation Enhancements

- Autogenerated schema snapshot (`Generated-Config.md`) complements curated `Config-Registry.md`.
- Project structure updated to reflect new modules, tooling, and invariants.
- Perf methodology kept separate; noted future perf collector module.

### Backward Compatibility

- `core.llm.factory` preserved (thin wrappers) to avoid breaking existing imports; marked transitional (removal planned after downstream migration).
- `generate()` still returns raw text; new `generate_result()` offers structured data.
- Migration auto-adds `schema_version` for old YAML, prints warning.

### Risks Mitigated

- Future cyclic imports (early static guard in place).
- Config drift (autogen + sync test reduces risk of undocumented keys).
- Provider internals leakage to perf scripts (now rely on GenerationResult contract & events plan).

### Known Gaps / Next Focus

- Thread-safety: `_load_provider` not yet locked (race possibility on parallel first access).
- EventBus still minimal; payload versioning & subscription API pending.
- GenerationResult lacks error/status fields (extension planned before perf collector).
- Observability & perf modules not yet instantiated (stubs to be introduced next sprint).
- ENV parsing could be more robust (bool/int detection improvements, logging overrides).

### Suggested Next Sprint Candidates

1. EventBus formalization (subscribe, versioned payload, async option).
2. Thread-safe provider loading + unload policy (LRU / max loaded limit).
3. PerfCollector module consuming events (p50/p95 decode latencies, regression signals).
4. Observability module (structured logging + metrics export skeleton).
5. Extend GenerationResult with status/error + version field.
6. ENV override logging & normalization (true/false/1/0/yes/no).
7. AST-based import graph (replace regex) + DOT export for docs.
8. RAG & Memory interface skeletons (Protocol/ABC) + config stubs activation.

### How This Refactor Improves Mia

- Decoupled evolution: adding/removing modules (perf, rag) no longer risks breaking core LLM path.
- Stable interfaces (GenerationResult, capability routing) enable perf & evaluation layers without invasive changes.
- Stronger governance: architectural invariants become test-enforced, reducing regressions as complexity grows.
- Documentation -> Code alignment automated, lowering onboarding & drift costs.

---
Part 2

## Phase 0 Kickoff (Опорные контракты → реализация)

**Статус:** Спецификации ключевых контрактов приняты (ADR-0006 Error Taxonomy, ADR-0011 EventBus v1, ADR-0012 GenerationResult v2). Цели текущего спринта смещены: от рефакторинга модульности к непосредственной реализации контрактов и архитектурных инвариантов.

### Что сделано

- Зафиксированы цели спринта в `.instructions.md` (раздел 3) — обновлён список Deliverables и KPI.
- В `planning.md` введено разделение Spec vs Impl (прозрачность готовности, Gate для UI Phase 2).
- Сформирован перечень тестов для enforcement (EventBus, GenerationResult v2, Error Taxonomy, AST импорт-граф).
- Определены минимальные метрики EventBus (events_total, handler_exceptions_total, dispatch_latency_accum_ms + dispatch_count для будущих percentiles).
- Уточнены правила импортов, требующие AST анализа (запрет обратных зависимостей llm←perf, modules→scripts и др.).
- Очерчена стратегия миграции GenerationResult: единый возврат структуры вместо legacy plain text пути (будет удалён после внедрения).

### Наблюдения / Вывод

- Чёткая граница между спецификациями и реализацией устраняет риск преждевременного запуска UI.
- Унифицированный GenerationResult упростит поток данных в перф и будущий UI (меньше условной логики).
- Ранний AST контроль дешевле, чем последующее разруливание скрытых циклов.

### Риски

| Риск | Митигатор |
|------|-----------|
| Пропуск error_type в экзотической ветке | Централизованная фабрика ошибок + тест перечисления |
| Лишняя накладная задержка EventBus | Минималистичная sync реализация + perf smoke сравнение (<2% целевой порог) |
| Ложные срабатывания AST правил | Ограниченный whitelist + возможность локально пометить исключения (comment pragma) |
| Частичное применение GenerationResult v2 | Контрактный тест, grep на legacy поля, удаление старого пути после зелёных тестов |

### Следующие шаги (имплементация)

1. Реализовать `core/eventbus` (subscribe, emit, safe handler invoke, метрики).
2. Интегрировать GenerationResult v2 в LLM генерацию (подсчёт токенов, timings.total_ms).
3. Рефактор ошибок на enum error_type (устранить «магические» строки).
4. Написать AST builder + правила и тест (запрещённые рёбра).
5. Обновить события GenerationStarted / Chunk / Completed (correlation_id, вложенный summary в Completed).
6. Добавить негативные тесты (неизвестный error_type, handler бросает исключение, запрещённый импорт).
7. (Опц.) Stub генератор Events Registry для синхронизации `Events.md`.

### Как улучшает систему

- Повышает воспроизводимость: стандартный результат генерации и формализованный список событий.
- Улучшает наблюдаемость: метрики на EventBus и структурированные ошибки.
- Снижает технический риск: ранний стоп несанкционированных зависимостей.
- Подготавливает основу для UI streaming и перф метрик без дополнительных миграций.

### Контроль успеха (Definition Snapshot)

- Все тесты из плана (EventBus, GenerationResult v2, Error Taxonomy, AST) зелёные.
- `generate()` возвращает объект с `version=2`, `status in {ok,error}`; при ошибке заполнены `error_type` и `message` без PII.
- Нет найденных legacy обращений к старому формату (grep / тест проходит).
- EventBus доставляет событие всем подписчикам; handler исключения не прерывают цепочку; метрики отражают количество событий.
- Импорт-граф тест не фиксирует запрещённых рёбер.

---
